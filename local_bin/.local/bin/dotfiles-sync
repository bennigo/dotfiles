#!/bin/bash
set -euo pipefail

# Enhanced Dotfiles Sync Script with Password Store Support
# Syncs: dotfiles + claude-private + password-store
# Generates meaningful commit messages based on actual changes

DOTFILES_DIR="$HOME/.dotfiles"
CLAUDE_PRIVATE_DIR="$DOTFILES_DIR/claude-private"
PASSWORD_STORE_DIR="${PASSWORD_STORE_DIR:-$HOME/.password-store}"

# Colors for output
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
NC='\033[0m' # No Color

# Helper functions
log_info() {
    echo -e "${BLUE}[INFO]${NC} $1"
}

log_success() {
    echo -e "${GREEN}[SUCCESS]${NC} $1"
}

log_warning() {
    echo -e "${YELLOW}[WARNING]${NC} $1"
}

log_error() {
    echo -e "${RED}[ERROR]${NC} $1"
}

# Check if directory is a git repository (handles both regular repos and submodules)
is_git_repo() {
    [ -d "$1/.git" ] || [ -f "$1/.git" ]
}

# Generate intelligent commit message based on file changes
generate_commit_message() {
    local repo_dir="$1"
    local repo_name="$2"

    cd "$repo_dir"

    # Get list of modified files
    local modified_files=$(git diff --cached --name-only)
    local new_files=$(git diff --cached --name-only --diff-filter=A)
    local deleted_files=$(git diff --cached --name-only --diff-filter=D)

    if [ -z "$modified_files" ]; then
        echo "Update $repo_name configuration"
        return
    fi

    local message=""
    local details=()

    # Analyze changes for claude-private
    if [[ "$repo_name" == "claude-private" ]]; then
        if echo "$modified_files" | grep -q "\.claude.*\.json"; then
            details+=("session data")
        fi
        if echo "$modified_files" | grep -q "\.claude/todos/"; then
            details+=("task updates")
        fi
        if echo "$modified_files" | grep -q "\.claude/projects/"; then
            details+=("project history")
        fi
        if echo "$modified_files" | grep -q "\.claude/shell-snapshots/"; then
            details+=("command snapshots")
        fi
        if echo "$modified_files" | grep -q "\.claude.*\.md"; then
            details+=("documentation")
        fi
        if echo "$modified_files" | grep -q "\.claude/settings"; then
            details+=("preferences")
        fi
        if echo "$modified_files" | grep -q "\.credentials"; then
            details+=("credentials")
        fi
    fi

    # Analyze changes for main dotfiles
    if [[ "$repo_name" == "dotfiles" ]]; then
        if echo "$modified_files" | grep -q "ansible/"; then
            details+=("ansible automation")
        fi
        if echo "$modified_files" | grep -q "sway\|waybar\|rofi\|mako"; then
            details+=("desktop environment")
        fi
        if echo "$modified_files" | grep -q "neovim\|tmux\|zsh"; then
            details+=("development tools")
        fi
        if echo "$modified_files" | grep -q "system/"; then
            details+=("system configuration")
        fi
        if echo "$modified_files" | grep -q "\.local/bin"; then
            details+=("custom scripts")
        fi
        if echo "$modified_files" | grep -q "claude-private"; then
            details+=("claude submodule")
        fi
    fi

    # Build commit message
    if [ ${#details[@]} -eq 0 ]; then
        if [ -n "$new_files" ]; then
            message="Add new files to $repo_name"
        elif [ -n "$deleted_files" ]; then
            message="Remove files from $repo_name"
        else
            message="Update $repo_name configuration"
        fi
    else
        case ${#details[@]} in
            1)
                message="Update ${details[0]}"
                ;;
            2)
                message="Update ${details[0]} and ${details[1]}"
                ;;
            *)
                message="Update $(IFS=', '; echo "${details[*]:0:$((${#details[@]}-1))}") and ${details[-1]}"
                ;;
        esac
    fi

    # Add file count context
    local file_count=$(echo "$modified_files" | wc -l)
    if [ "$file_count" -gt 5 ]; then
        message="$message ($file_count files)"
    fi

    echo "$message"
}

# Generate intelligent commit message for password-store
generate_pass_commit_message() {
    local repo_dir="$1"
    cd "$repo_dir"

    local modified_files=$(git diff --cached --name-only)
    local new_files=$(git diff --cached --name-only --diff-filter=A)
    local deleted_files=$(git diff --cached --name-only --diff-filter=D)

    if [ -z "$modified_files" ]; then
        echo "Update password store"
        return
    fi

    local details=()

    # Analyze which credential categories changed
    if echo "$modified_files" | grep -q "^database/"; then
        details+=("database credentials")
    fi
    if echo "$modified_files" | grep -q "^ansible/"; then
        details+=("ansible vault")
    fi
    if echo "$modified_files" | grep -q "^accounts/"; then
        details+=("account credentials")
    fi
    if echo "$modified_files" | grep -q "^tokens/"; then
        details+=("API tokens")
    fi

    # Count operations
    local new_count=$(echo "$new_files" | grep -c . || echo 0)
    local del_count=$(echo "$deleted_files" | grep -c . || echo 0)
    local mod_count=$(($(echo "$modified_files" | wc -l) - new_count - del_count))

    # Build message
    local message=""
    if [ ${#details[@]} -eq 0 ]; then
        if [ "$new_count" -gt 0 ]; then
            message="Add $new_count new credential(s)"
        elif [ "$del_count" -gt 0 ]; then
            message="Remove $del_count credential(s)"
        else
            message="Update password store credentials"
        fi
    else
        case ${#details[@]} in
            1)
                message="Update ${details[0]}"
                ;;
            2)
                message="Update ${details[0]} and ${details[1]}"
                ;;
            *)
                message="Update $(IFS=', '; echo "${details[*]:0:$((${#details[@]}-1))}") and ${details[-1]}"
                ;;
        esac
    fi

    # Add operation counts if significant
    if [ "$new_count" -gt 0 ] || [ "$del_count" -gt 0 ]; then
        local ops=""
        [ "$new_count" -gt 0 ] && ops="$new_count added"
        [ "$del_count" -gt 0 ] && ops="${ops:+$ops, }$del_count removed"
        [ "$mod_count" -gt 0 ] && ops="${ops:+$ops, }$mod_count modified"
        message="$message ($ops)"
    fi

    echo "$message"
}

# Sync password-store repository
sync_password_store() {
    if [[ ! -d "$PASSWORD_STORE_DIR" ]]; then
        log_warning "Password store directory not found: $PASSWORD_STORE_DIR"
        return 0
    fi

    if ! is_git_repo "$PASSWORD_STORE_DIR"; then
        log_warning "Password store is not a git repository"
        return 0
    fi

    log_info "Checking password-store for changes..."
    cd "$PASSWORD_STORE_DIR"

    # Pull latest changes first
    log_info "Pulling latest password-store changes..."
    if ! git pull --rebase --autostash 2>&1 | grep -v "Already up to date"; then
        log_warning "Pull had minor issues (likely up to date)"
    fi

    # Check if there are any local changes
    if git diff --quiet && git diff --cached --quiet; then
        log_info "No changes in password-store"
        return 0
    fi

    # Stage all changes
    git add .

    # Check if there are staged changes
    if git diff --cached --quiet; then
        log_info "No staged changes in password-store"
        return 0
    fi

    # Generate and apply commit message
    local commit_msg=$(generate_pass_commit_message "$PASSWORD_STORE_DIR")

    log_info "Committing password-store changes: $commit_msg"
    git commit -m "$commit_msg"

    # Push changes
    log_info "Pushing password-store changes..."
    if git push; then
        log_success "Password-store changes pushed successfully"
    else
        log_error "Failed to push password-store changes"
        return 1
    fi
}

# Sync claude-private repository
sync_claude_private() {
    if ! is_git_repo "$CLAUDE_PRIVATE_DIR"; then
        log_warning "Claude private directory is not a git repository"
        return 0
    fi

    log_info "Checking claude-private for changes..."
    cd "$CLAUDE_PRIVATE_DIR"

    # Check if there are any changes
    if git diff --quiet && git diff --cached --quiet; then
        log_info "No changes in claude-private"
        return 0
    fi

    # Stage all changes
    git add .

    # Check if there are staged changes
    if git diff --cached --quiet; then
        log_info "No staged changes in claude-private"
        return 0
    fi

    # Generate and apply commit message
    local commit_msg=$(generate_commit_message "$CLAUDE_PRIVATE_DIR" "claude-private")

    log_info "Committing claude-private changes: $commit_msg"
    git commit -m "$commit_msg"

    # Push changes
    log_info "Pushing claude-private changes..."
    if git push; then
        log_success "Claude-private changes pushed successfully"
    else
        log_error "Failed to push claude-private changes"
        return 1
    fi
}

# Sync main dotfiles repository
sync_dotfiles() {
    if ! is_git_repo "$DOTFILES_DIR"; then
        log_error "Dotfiles directory is not a git repository"
        return 1
    fi

    log_info "Checking main dotfiles for changes..."
    cd "$DOTFILES_DIR"

    # Check if there are any changes (including submodule changes)
    if git diff --quiet && git diff --cached --quiet; then
        # Check for submodule changes
        if git submodule status | grep -q '^+'; then
            log_info "Submodule updates detected"
        else
            log_info "No changes in main dotfiles"
            return 0
        fi
    fi

    # Stage all changes
    git add .

    # Check if there are staged changes
    if git diff --cached --quiet; then
        log_info "No staged changes in main dotfiles"
        return 0
    fi

    # Generate and apply commit message
    local commit_msg=$(generate_commit_message "$DOTFILES_DIR" "dotfiles")

    log_info "Committing dotfiles changes: $commit_msg"
    git commit -m "$commit_msg"

    # Push changes
    log_info "Pushing dotfiles changes..."
    if git push; then
        log_success "Dotfiles changes pushed successfully"
    else
        log_error "Failed to push dotfiles changes"
        return 1
    fi
}

# Show status of all repositories
show_status() {
    log_info "Checking repository status..."
    echo

    # Password Store
    echo -e "${BLUE}Password Store:${NC} $PASSWORD_STORE_DIR"
    if [[ -d "$PASSWORD_STORE_DIR" ]] && is_git_repo "$PASSWORD_STORE_DIR"; then
        cd "$PASSWORD_STORE_DIR"
        if git diff --quiet && git diff --cached --quiet; then
            echo -e "  ${GREEN}✓${NC} No uncommitted changes"
        else
            echo -e "  ${YELLOW}⚠${NC} Uncommitted changes present"
        fi

        local ahead=$(git rev-list --count @{u}..HEAD 2>/dev/null || echo "0")
        local behind=$(git rev-list --count HEAD..@{u} 2>/dev/null || echo "0")

        if [ "$ahead" -gt 0 ]; then
            echo -e "  ${YELLOW}↑${NC} $ahead commit(s) ahead of remote"
        fi
        if [ "$behind" -gt 0 ]; then
            echo -e "  ${YELLOW}↓${NC} $behind commit(s) behind remote"
        fi
        if [ "$ahead" -eq 0 ] && [ "$behind" -eq 0 ]; then
            echo -e "  ${GREEN}✓${NC} Synced with remote"
        fi
    else
        echo -e "  ${RED}✗${NC} Not a git repository"
    fi
    echo

    # Claude Private
    echo -e "${BLUE}Claude Private:${NC} $CLAUDE_PRIVATE_DIR"
    if [[ -d "$CLAUDE_PRIVATE_DIR" ]] && is_git_repo "$CLAUDE_PRIVATE_DIR"; then
        cd "$CLAUDE_PRIVATE_DIR"
        if git diff --quiet && git diff --cached --quiet; then
            echo -e "  ${GREEN}✓${NC} No uncommitted changes"
        else
            echo -e "  ${YELLOW}⚠${NC} Uncommitted changes present"
        fi

        local ahead=$(git rev-list --count @{u}..HEAD 2>/dev/null || echo "0")
        local behind=$(git rev-list --count HEAD..@{u} 2>/dev/null || echo "0")

        if [ "$ahead" -gt 0 ]; then
            echo -e "  ${YELLOW}↑${NC} $ahead commit(s) ahead of remote"
        fi
        if [ "$behind" -gt 0 ]; then
            echo -e "  ${YELLOW}↓${NC} $behind commit(s) behind remote"
        fi
        if [ "$ahead" -eq 0 ] && [ "$behind" -eq 0 ]; then
            echo -e "  ${GREEN}✓${NC} Synced with remote"
        fi
    else
        echo -e "  ${YELLOW}⚠${NC} Not a git repository"
    fi
    echo

    # Main Dotfiles
    echo -e "${BLUE}Main Dotfiles:${NC} $DOTFILES_DIR"
    if [[ -d "$DOTFILES_DIR" ]] && is_git_repo "$DOTFILES_DIR"; then
        cd "$DOTFILES_DIR"
        if git diff --quiet && git diff --cached --quiet; then
            echo -e "  ${GREEN}✓${NC} No uncommitted changes"
        else
            echo -e "  ${YELLOW}⚠${NC} Uncommitted changes present"
        fi

        local ahead=$(git rev-list --count @{u}..HEAD 2>/dev/null || echo "0")
        local behind=$(git rev-list --count HEAD..@{u} 2>/dev/null || echo "0")

        if [ "$ahead" -gt 0 ]; then
            echo -e "  ${YELLOW}↑${NC} $ahead commit(s) ahead of remote"
        fi
        if [ "$behind" -gt 0 ]; then
            echo -e "  ${YELLOW}↓${NC} $behind commit(s) behind remote"
        fi
        if [ "$ahead" -eq 0 ] && [ "$behind" -eq 0 ]; then
            echo -e "  ${GREEN}✓${NC} Synced with remote"
        fi
    else
        echo -e "  ${RED}✗${NC} Not a git repository"
    fi
}

# Show usage
show_usage() {
    cat << EOF
Usage: dotfiles-sync [OPTIONS]

Intelligently sync dotfiles, claude-private, and password-store repositories.

OPTIONS:
    -h, --help          Show this help message
    -v, --verbose       Enable verbose output
    -n, --dry-run       Show what would be done without making changes
    -c, --claude-only   Sync only claude-private repository
    -d, --dotfiles-only Sync only main dotfiles repository
    -p, --pass-only     Sync only password-store repository
    -a, --all           Sync all repositories (default)
    -s, --status        Show status of all repositories

EXAMPLES:
    dotfiles-sync                    # Sync all repositories
    dotfiles-sync --pass-only        # Sync only password-store
    dotfiles-sync --status           # Check status without syncing
    dotfiles-sync --dry-run          # Preview changes

REPOSITORIES MANAGED:
    - Main dotfiles:     $DOTFILES_DIR
    - Claude private:    $CLAUDE_PRIVATE_DIR
    - Password store:    $PASSWORD_STORE_DIR

EOF
}

# Parse command line arguments
DRY_RUN=false
VERBOSE=false
CLAUDE_ONLY=false
DOTFILES_ONLY=false
PASS_ONLY=false
SHOW_STATUS=false

while [[ $# -gt 0 ]]; do
    case $1 in
        -h|--help)
            show_usage
            exit 0
            ;;
        -v|--verbose)
            VERBOSE=true
            shift
            ;;
        -n|--dry-run)
            DRY_RUN=true
            shift
            ;;
        -c|--claude-only)
            CLAUDE_ONLY=true
            shift
            ;;
        -d|--dotfiles-only)
            DOTFILES_ONLY=true
            shift
            ;;
        -p|--pass-only)
            PASS_ONLY=true
            shift
            ;;
        -a|--all)
            # Default behavior, do nothing
            shift
            ;;
        -s|--status)
            SHOW_STATUS=true
            shift
            ;;
        *)
            log_error "Unknown option: $1"
            show_usage
            exit 1
            ;;
    esac
done

# Handle status check
if [[ "$SHOW_STATUS" == true ]]; then
    show_status
    exit 0
fi

# Main execution
main() {
    log_info "Starting dotfiles synchronization..."

    if [[ "$DRY_RUN" == true ]]; then
        log_warning "DRY RUN MODE - No changes will be made"
    fi

    # Check if directories exist
    if [[ ! -d "$DOTFILES_DIR" ]]; then
        log_error "Dotfiles directory not found: $DOTFILES_DIR"
        exit 1
    fi

    # Sync repositories
    local exit_code=0

    # Sync password-store first (credentials may be needed)
    if [[ "$DOTFILES_ONLY" != true && "$CLAUDE_ONLY" != true ]]; then
        if [[ "$DRY_RUN" == true ]]; then
            log_info "[DRY RUN] Would sync password-store repository"
        else
            sync_password_store || exit_code=$?
        fi
    fi

    # Sync claude-private
    if [[ "$DOTFILES_ONLY" != true && "$PASS_ONLY" != true ]]; then
        if [[ "$DRY_RUN" == true ]]; then
            log_info "[DRY RUN] Would sync claude-private repository"
        else
            sync_claude_private || exit_code=$?
        fi
    fi

    # Sync main dotfiles
    if [[ "$CLAUDE_ONLY" != true && "$PASS_ONLY" != true ]]; then
        if [[ "$DRY_RUN" == true ]]; then
            log_info "[DRY RUN] Would sync main dotfiles repository"
        else
            sync_dotfiles || exit_code=$?
        fi
    fi

    if [[ $exit_code -eq 0 ]]; then
        log_success "Dotfiles synchronization completed successfully!"
    else
        log_error "Dotfiles synchronization completed with errors"
    fi

    return $exit_code
}

# Run main function
main "$@"